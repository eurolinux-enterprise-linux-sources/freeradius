commit ecb3cd1dbedb764ab98532dae5e0b5bfc9571b00
Author: Alan T. DeKok <aland@freeradius.org>
Date:   Thu Dec 1 14:21:03 2011 +0100

    Perl clone should be called sequentially, not in parallel.
    
    Adding a mutex fixes this.
    
    Patch from Eike Dehling

diff --git a/src/modules/rlm_perl/rlm_perl.c b/src/modules/rlm_perl/rlm_perl.c
index 5c82e89..4682ba5 100644
--- a/src/modules/rlm_perl/rlm_perl.c
+++ b/src/modules/rlm_perl/rlm_perl.c
@@ -77,6 +77,8 @@ typedef struct perl_inst {
 	char	*perl_flags;
 	PerlInterpreter *perl;
 	pthread_key_t	*thread_key;
+
+	pthread_mutex_t clone_mutex;
 } PERL_INST;
 /*
  *	A mapping of configuration file names to internal variables.
@@ -434,6 +436,8 @@ static int perl_instantiate(CONF_SECTION *conf, void **instance)
 	 */
 
 #ifdef USE_ITHREADS
+	pthread_mutex_init(&inst->clone_mutex, NULL);
+
 	inst->thread_key = rad_malloc(sizeof(*inst->thread_key));
 	memset(inst->thread_key,0,sizeof(*inst->thread_key));
 	
@@ -656,8 +660,10 @@ static int rlmperl_call(void *instance, REQUEST *request, char *function_name)
 	HV		*rad_request_hv;
 	HV		*rad_request_proxy_hv;
 	HV		*rad_request_proxy_reply_hv;
-
+	
 #ifdef USE_ITHREADS
+	pthread_mutex_lock(&inst->clone_mutex);
+
 	PerlInterpreter *interp;
 
 	interp = rlm_perl_clone(inst->perl,inst->thread_key);
@@ -665,9 +671,12 @@ static int rlmperl_call(void *instance, REQUEST *request, char *function_name)
 	  dTHXa(interp);
 	  PERL_SET_CONTEXT(interp);
 	}
+	
+	pthread_mutex_unlock(&inst->clone_mutex);
 #else
 	PERL_SET_CONTEXT(inst->perl);
 #endif
+
 	{
 	dSP;
 
@@ -974,6 +983,7 @@ static int perl_detach(void *instance)
 
 #ifdef USE_ITHREADS
 	rlm_perl_destruct(inst->perl);
+	pthread_mutex_destroy(&inst->clone_mutex);
 #else
 	perl_destruct(inst->perl);
 	perl_free(inst->perl);
